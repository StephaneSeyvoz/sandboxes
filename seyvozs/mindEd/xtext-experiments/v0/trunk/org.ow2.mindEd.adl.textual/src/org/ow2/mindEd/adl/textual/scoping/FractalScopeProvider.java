/*
 * generated by Xtext
 */
package org.ow2.mindEd.adl.textual.scoping;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.ow2.mindEd.adl.textual.fractal.ArchitectureDefinition;
import org.ow2.mindEd.adl.textual.fractal.BindingDefinition;
import org.ow2.mindEd.adl.textual.fractal.CompositeDefinition;
import org.ow2.mindEd.adl.textual.fractal.CompositeElement;
import org.ow2.mindEd.adl.textual.fractal.CompositeSuperTypeDefinition;
import org.ow2.mindEd.adl.textual.fractal.HostedInterfaceDefinition;
import org.ow2.mindEd.adl.textual.fractal.PrimitiveDefinition;
import org.ow2.mindEd.adl.textual.fractal.PrimitiveElement;
import org.ow2.mindEd.adl.textual.fractal.PrimitiveSuperTypeDefinition;
import org.ow2.mindEd.adl.textual.fractal.ProvidedInterfaceDefinition;
import org.ow2.mindEd.adl.textual.fractal.RequiredInterfaceDefinition;
import org.ow2.mindEd.adl.textual.fractal.TemplateSpecifier;
import org.ow2.mindEd.adl.textual.fractal.TypeDefinition;
import org.ow2.mindEd.adl.textual.fractal.TypeReference;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class FractalScopeProvider extends AbstractDeclarativeScopeProvider {


	// VERY seful debug method
//	@Override
//	public IScope getScope(EObject context, EReference reference){
//		System.out.println(
//				"scope_" + reference.getEContainingClass().getName()
//				+ "_" + reference.getName()
//				+ "(" + context.eClass().getName() + ", ..)"
//				);
//		return super.getScope(context, reference);
//	}
	
	/**
	 * Here we need to handle local templates:
	 * composite TemplatedType<LocalTemplate conformsto AbstractType> { ... contains LocalTemplate as template; ...}
	 * Where LocalTemplateName has to be recognized as a valid candidate for SubComponentDefinition.
	 * 
	 */
//	public IScope scope_SubComponentDefinition_type(final SubComponentDefinition subCompDef, final EReference ref) {
//		EObject container = subCompDef.eContainer();
//		// Find the parent host definition
//		while (!(container instanceof CompositeDefinition))
//			container = container.eContainer();
//		CompositeDefinition hostCompositeDef = (CompositeDefinition) container;
//		EList<TemplateSpecifier> templateSpecifiers = hostCompositeDef.getTemplateSpecifiers();
//
//		// Get the default resolved scope
//		Iterable<IEObjectDescription> scopeElementsDescriptions = delegateGetScope(subCompDef, ref).getAllElements();
//		
//		/*
//		 * Here we want to manage the first case seen in the comment ("LocalTemplate" example). 
//		 */
//		// TODO FIXME seems to always return... nothing
//		IScope templateSpecifiersScope = Scopes.scopeFor(templateSpecifiers);
//
//		return MultimapBasedScope.createScope(templateSpecifiersScope, scopeElementsDescriptions, false);
//	}

		// OLD TENTATIVE
//	public IScope scope_SubComponentDefinition_type(final SubComponentDefinition subCompDef, final EReference ref) {
//		EObject container = subCompDef.eContainer();
//		// Find the parent host definition
//		while (!(container instanceof CompositeDefinition))
//			container = container.eContainer();
//		CompositeDefinition hostCompositeDef = (CompositeDefinition) container;
//		EList<TemplateSpecifier> templateSpecifiers = hostCompositeDef.getTemplateSpecifiers();
//
//		// Get the default resolved scope
//		Iterable<IEObjectDescription> scopeElementsDescriptions = delegateGetScope(subCompDef, ref).getAllElements();
//
//		// Should be EList of TypeReference
//		EList<IEObjectDescription> scopeElementsDescriptionsToKeep = new BasicEList<IEObjectDescription>();
//
//		// Then filter the default scope to remove outer TemplateSpecifiers elements (not included in the local scope)  
//		for (IEObjectDescription currentScopeElementDescription : scopeElementsDescriptions) {
//			// SubComponentDefinition_type is typed TypeReference, sub-classes: TemplateSpecifier and ArchitectureDefinition
//			TypeReference currentScopeElement = (TypeReference) currentScopeElementDescription.getEObjectOrProxy();
//			if ((currentScopeElement instanceof TemplateSpecifier) && (!templateSpecifiers.contains(currentScopeElement)))
//				continue;
//			else
//				scopeElementsDescriptionsToKeep.add(currentScopeElementDescription);
//		}
//
//		return MultimapBasedScope.createScope(IScope.NULLSCOPE, scopeElementsDescriptionsToKeep, false);
//	}
	
	/*
	 * And also in other components:
	 * composite AnotherComp { ... contains TemplatedType<RealConcreteType> ... }
	 * In this case we need to check/filter RealConcreteType to see if it's compatible with "AbstractType".
	 */
//	public IScope scope_SubComponentDefinition_templatesList(final SubComponentDefinition subCompDef, final EReference ref) {
//		// Get the default resolved scope
//		Iterable<IEObjectDescription> scopeElementsDescriptions = delegateGetScope(subCompDef, ref).getAllElements();
//		
//		// Filter to keep types compatible with the destination template
//		// TODO: determine how multiple elements in a list are handled, according to the order of template elements
//		
//		return Scopes.scopeFor(subCompDef.getTemplatesList());
//	}

	/*
	 * Who are the possible TemplateDefinition-s at this place ?
	 */
//	public IScope scope_TemplateDefinition_typeReference(TemplateDefinition currentTemplateDef, EReference ref) {
//		// Get the default resolved scope
//		Iterable<IEObjectDescription> scopeElementsDescriptions = delegateGetScope(currentTemplateDef, ref).getAllElements();
//		
//		// We want to get the list from the host SubComponentDefinition (eContainer), which is feature SubComponentDefinition_templatesList
//		SubComponentDefinition hostSubCompDef = (SubComponentDefinition) currentTemplateDef.eContainer();
//		EList<TemplateDefinition> hosttemplatesList = (EList<TemplateDefinition>) hostSubCompDef.getTemplatesList();
//		int indexOfTemplateDefinition = hosttemplatesList.indexOf(currentTemplateDef);
//		
//		TypeReference hostType = hostSubCompDef.getType();
//		if (! (hostType instanceof CompositeDefinition))
//			return IScope.NULLSCOPE; // Error ! the SubComponent we are worrying about should be a Composite
//		
//		// else we have a CompositeDefinition...
//		
//		CompositeDefinition compositeHostType = (CompositeDefinition) hostType;
//		EList<TemplateSpecifier> templateSpecifiers = compositeHostType.getTemplateSpecifiers();
//		
//		// Let's find the matching TemplateSpecifier in the host definition
//		TemplateSpecifier accordingTemplateSpecifier = templateSpecifiers.get(indexOfTemplateDefinition);
//		TypeDefinition accordingTemplateType = accordingTemplateSpecifier.getTypeReference();
//		
//		// Now filter the initial scopeElementsDescriptions proposed by Xtext to keep only compatible types
//		
//		// Should be EList of TypeReference
//		EList<IEObjectDescription> scopeElementsDescriptionsToKeep = new BasicEList<IEObjectDescription>();
//		
//		ArchitectureDefinition currentArchDef;
//		
//		// Then filter the default scope to remove outer TemplateSpecifiers elements (not included in the local scope)  
//		for (IEObjectDescription currentScopeElementDescription : scopeElementsDescriptions) {
//			// SubComponentDefinition_type is typed TypeReference, sub-classes: TemplateSpecifier and ArchitectureDefinition
//			TypeReference currentScopeElement = (TypeReference) currentScopeElementDescription.getEObjectOrProxy();
//			if ((currentScopeElement instanceof TemplateSpecifier)) // TODO: not handled yet
//				continue;
//			else { // ArchitectureDefinition 
//				currentArchDef = (ArchitectureDefinition) currentScopeElement;
//				EList<ArchitectureDefinition> superTypes = currentArchDef.getSuperTypes();
//				if ((superTypes != null) && superTypes.contains(accordingTemplateType)) // TODO: make it recursive: Not recursive yet
//					scopeElementsDescriptionsToKeep.add(currentScopeElementDescription);
//			}
//		}
//
//		return MultimapBasedScope.createScope(IScope.NULLSCOPE, scopeElementsDescriptionsToKeep, false);
//	}
	
	/*
	 * Here I guess the context (first argument) should have been TemplateDefinition...
	 * but as it's included in a list, maybe it's a bit different.
	 */
//	public IScope scope_TemplateDefinition_typeReference(SubComponentDefinition ctx, EReference ref) {
//		// Get the default resolved scope
//		Iterable<IEObjectDescription> scopeElementsDescriptions = delegateGetScope(ctx, ref).getAllElements();
//		
//		ref.eContainer();
//		ref.eContainingFeature();
//		
//		return MultimapBasedScope.createScope(IScope.NULLSCOPE, scopeElementsDescriptions, false);
//	}
	
	// Heaviest methods ever: will need further optimization, not sure how to improve templated ELists behavior.
	public IScope scope_BindingDefinition_sourceInterface(final BindingDefinition bindingDef, final EReference ref) {

		ArchitectureDefinition sourceComponentArchDef = null;

		TypeReference currArchDefOrTemplate = bindingDef.getSourceParent().getType();

		// If the source parent is a subcomponent
		if (!bindingDef.isIsSrcParentThis())
			if (currArchDefOrTemplate instanceof ArchitectureDefinition)
				sourceComponentArchDef = (ArchitectureDefinition) currArchDefOrTemplate;
			else if (currArchDefOrTemplate instanceof TemplateSpecifier)
				sourceComponentArchDef = ((TemplateSpecifier) currArchDefOrTemplate).getTypeReference();
			else // error case
				return IScope.NULLSCOPE;
		else  {
			// if the source parent is "this"
			EObject container = bindingDef.eContainer();
			// Find the parent host definition
			while (!(container instanceof CompositeDefinition))
				container = container.eContainer();
			sourceComponentArchDef = (ArchitectureDefinition) container;
		}

		if (sourceComponentArchDef instanceof TypeDefinition) {
			// Get all the elements
			EList<HostedInterfaceDefinition> elements = ((TypeDefinition) sourceComponentArchDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			if (!bindingDef.isIsSrcParentThis()) {
				EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof RequiredInterfaceDefinition) {
						reqItfList.add((RequiredInterfaceDefinition) currentEObject);
					}
				}
				// We also want all required interfaces coming from Super Types
				reqItfList.addAll(listAllRequiredInterfacesFromArchDefSuperTypes((TypeDefinition) sourceComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(reqItfList);
			} else {
				EList<ProvidedInterfaceDefinition> pvdItfList = new BasicEList<ProvidedInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof ProvidedInterfaceDefinition) {
						pvdItfList.add((ProvidedInterfaceDefinition) currentEObject);
					}
				}
				// We also want all provided interfaces coming from Super Types
				pvdItfList.addAll(listAllProvidedInterfacesFromArchDefSuperTypes((TypeDefinition) sourceComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(pvdItfList);
			}
		} else if (sourceComponentArchDef instanceof CompositeDefinition) {
			// Get all the elements
			EList<CompositeElement> elements = ((CompositeDefinition) sourceComponentArchDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			if (!bindingDef.isIsSrcParentThis()) {
				EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof RequiredInterfaceDefinition) {
						reqItfList.add((RequiredInterfaceDefinition) currentEObject);
					}
				}
				// We also want all required interfaces coming from Super Types
				reqItfList.addAll(listAllRequiredInterfacesFromArchDefSuperTypes((CompositeDefinition) sourceComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(reqItfList);
			} else {
				EList<ProvidedInterfaceDefinition> pvdItfList = new BasicEList<ProvidedInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof ProvidedInterfaceDefinition) {
						pvdItfList.add((ProvidedInterfaceDefinition) currentEObject);
					}
				}
				// We also want all provided interfaces coming from Super Types
				pvdItfList.addAll(listAllProvidedInterfacesFromArchDefSuperTypes((CompositeDefinition) sourceComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(pvdItfList);
			}
		} else if (sourceComponentArchDef instanceof PrimitiveDefinition) {
			// Get all the elements
			EList<PrimitiveElement> elements = ((PrimitiveDefinition) sourceComponentArchDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			if (!bindingDef.isIsSrcParentThis()) {
				EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof RequiredInterfaceDefinition) {
						reqItfList.add((RequiredInterfaceDefinition) currentEObject);
					}
				}
				// We also want all required interfaces coming from Super Types
				reqItfList.addAll(listAllRequiredInterfacesFromArchDefSuperTypes((PrimitiveDefinition) sourceComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(reqItfList);
			} else {
				EList<ProvidedInterfaceDefinition> pvdItfList = new BasicEList<ProvidedInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof ProvidedInterfaceDefinition) {
						pvdItfList.add((ProvidedInterfaceDefinition) currentEObject);
					}
				}
				// We also want all provided interfaces coming from Super Types
				pvdItfList.addAll(listAllProvidedInterfacesFromArchDefSuperTypes((PrimitiveDefinition) sourceComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(pvdItfList);
			}
		} else {
			// error case
			return IScope.NULLSCOPE;
		}
	}

	public IScope scope_BindingDefinition_targetInterface(final BindingDefinition bindingDef, final EReference ref) {

		ArchitectureDefinition targetComponentArchDef = null;

		TypeReference currArchDefOrTemplate = bindingDef.getTargetParent().getType();

		// If the source parent isn't a sub-component but "this"
		if (!bindingDef.isIsTgtParentThis())
			if (currArchDefOrTemplate instanceof ArchitectureDefinition)
				targetComponentArchDef = (ArchitectureDefinition) currArchDefOrTemplate;
			else if (currArchDefOrTemplate instanceof TemplateSpecifier)
				targetComponentArchDef = ((TemplateSpecifier) currArchDefOrTemplate).getTypeReference();
			else // error case
				return IScope.NULLSCOPE;
		else  {
			EObject container = bindingDef.eContainer();
			// Find the parent host definition
			while (!(container instanceof CompositeDefinition))
				container = container.eContainer();
			targetComponentArchDef = (ArchitectureDefinition) container;
		}

		if (targetComponentArchDef instanceof TypeDefinition) {
			// Get all the elements
			EList<HostedInterfaceDefinition> elements = ((TypeDefinition) targetComponentArchDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			if (!bindingDef.isIsTgtParentThis()) {
				EList<ProvidedInterfaceDefinition> pvdItfList = new BasicEList<ProvidedInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof ProvidedInterfaceDefinition) {
						pvdItfList.add((ProvidedInterfaceDefinition) currentEObject);
					}
				}
				// We also want all provided interfaces coming from Super Types
				pvdItfList.addAll(listAllProvidedInterfacesFromArchDefSuperTypes((TypeDefinition) targetComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(pvdItfList);
			} else {
				EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof RequiredInterfaceDefinition) {
						reqItfList.add((RequiredInterfaceDefinition) currentEObject);
					}
				}
				// We also want all required interfaces coming from Super Types
				reqItfList.addAll(listAllRequiredInterfacesFromArchDefSuperTypes((TypeDefinition) targetComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(reqItfList);
			}
		} else if (targetComponentArchDef instanceof CompositeDefinition) {
			// Get all the elements
			EList<CompositeElement> elements = ((CompositeDefinition) targetComponentArchDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			if (!bindingDef.isIsTgtParentThis()) {
				EList<ProvidedInterfaceDefinition> pvdItfList = new BasicEList<ProvidedInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof ProvidedInterfaceDefinition) {
						pvdItfList.add((ProvidedInterfaceDefinition) currentEObject);
					}
				}
				// We also want all provided interfaces coming from Super Types
				pvdItfList.addAll(listAllProvidedInterfacesFromArchDefSuperTypes((CompositeDefinition) targetComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(pvdItfList);
			} else {
				EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof RequiredInterfaceDefinition) {
						reqItfList.add((RequiredInterfaceDefinition) currentEObject);
					}
				}
				// We also want all required interfaces coming from Super Types
				reqItfList.addAll(listAllRequiredInterfacesFromArchDefSuperTypes((CompositeDefinition) targetComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(reqItfList);
			}
		} else if (targetComponentArchDef instanceof PrimitiveDefinition) {
			// Get all the elements
			EList<PrimitiveElement> elements = ((PrimitiveDefinition) targetComponentArchDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			if (!bindingDef.isIsTgtParentThis()) {
				EList<ProvidedInterfaceDefinition> pvdItfList = new BasicEList<ProvidedInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof ProvidedInterfaceDefinition) {
						pvdItfList.add((ProvidedInterfaceDefinition) currentEObject);
					}
				}
				// We also want all provided interfaces coming from Super Types
				pvdItfList.addAll(listAllProvidedInterfacesFromArchDefSuperTypes((PrimitiveDefinition) targetComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(pvdItfList);
			} else {
				EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();
				for (EObject currentEObject : elements) {
					if (currentEObject instanceof RequiredInterfaceDefinition) {
						reqItfList.add((RequiredInterfaceDefinition) currentEObject);
					}
				}
				// We also want all required interfaces coming from Super Types
				reqItfList.addAll(listAllRequiredInterfacesFromArchDefSuperTypes((PrimitiveDefinition) targetComponentArchDef));
				// Obtain and return a scope according to the computed list
				return Scopes.scopeFor(reqItfList);
			}
		} else {
			// error case
			return IScope.NULLSCOPE;
		}
	}

	private EList<RequiredInterfaceDefinition> listAllRequiredInterfacesFromArchDefSuperTypes(TypeDefinition archDef){
		EList<TypeDefinition> superTypes = archDef.getSuperTypes();

		EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();

		for (TypeDefinition currSuperArchDef : superTypes) {
			reqItfList.addAll(getAllArchDefRequiredInterfaces(currSuperArchDef));
			// we need a recursion in all supertypes
			listAllRequiredInterfacesFromArchDefSuperTypes(currSuperArchDef);
		}

		return reqItfList;
	}
	
	private EList<RequiredInterfaceDefinition> listAllRequiredInterfacesFromArchDefSuperTypes(CompositeDefinition archDef){
		EList<CompositeSuperTypeDefinition> superTypes = archDef.getSuperTypes();

		EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();

		for (CompositeSuperTypeDefinition currSuperArchDef : superTypes) {
			if (currSuperArchDef instanceof PrimitiveDefinition)
				reqItfList.addAll(getAllArchDefRequiredInterfaces((CompositeDefinition) currSuperArchDef));
			else if (currSuperArchDef instanceof TypeDefinition)
				reqItfList.addAll(getAllArchDefRequiredInterfaces((TypeDefinition) currSuperArchDef));
			
			// we need a recursion in all supertypes
			if (currSuperArchDef instanceof CompositeDefinition)
				listAllRequiredInterfacesFromArchDefSuperTypes((CompositeDefinition) currSuperArchDef);
			else if (currSuperArchDef instanceof TypeDefinition)
				listAllRequiredInterfacesFromArchDefSuperTypes((TypeDefinition) currSuperArchDef);
		}

		return reqItfList;
	}
	
	private EList<RequiredInterfaceDefinition> listAllRequiredInterfacesFromArchDefSuperTypes(PrimitiveDefinition archDef){
		EList<PrimitiveSuperTypeDefinition> superTypes = archDef.getSuperTypes();

		EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();

		for (PrimitiveSuperTypeDefinition currSuperArchDef : superTypes) {
			if (currSuperArchDef instanceof PrimitiveDefinition)
				reqItfList.addAll(getAllArchDefRequiredInterfaces((PrimitiveDefinition) currSuperArchDef));
			else if (currSuperArchDef instanceof TypeDefinition)
				reqItfList.addAll(getAllArchDefRequiredInterfaces((TypeDefinition) currSuperArchDef));
			
			// we need a recursion in all supertypes
			if (currSuperArchDef instanceof PrimitiveDefinition)
				listAllRequiredInterfacesFromArchDefSuperTypes((PrimitiveDefinition) currSuperArchDef);
			else if (currSuperArchDef instanceof TypeDefinition)
				listAllRequiredInterfacesFromArchDefSuperTypes((TypeDefinition) currSuperArchDef);
		}

		return reqItfList;
	}

	private EList<RequiredInterfaceDefinition> getAllArchDefRequiredInterfaces(ArchitectureDefinition archDef) {
		EList<RequiredInterfaceDefinition> reqItfList = new BasicEList<RequiredInterfaceDefinition>();

		if (archDef instanceof TypeDefinition) {
			// Get all the elements
			EList<HostedInterfaceDefinition> elements = ((TypeDefinition) archDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			for (EObject currentEObject : elements) {
				if (currentEObject instanceof RequiredInterfaceDefinition) {
					reqItfList.add((RequiredInterfaceDefinition) currentEObject);
				}
			}
		} else if (archDef instanceof CompositeDefinition) {
			// Get all the elements
			EList<CompositeElement> elements = ((CompositeDefinition) archDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			for (EObject currentEObject : elements) {
				if (currentEObject instanceof RequiredInterfaceDefinition) {
					reqItfList.add((RequiredInterfaceDefinition) currentEObject);
				}
			}
		} else if (archDef instanceof PrimitiveDefinition) {
			// Get all the elements
			EList<PrimitiveElement> elements = ((PrimitiveDefinition) archDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			for (EObject currentEObject : elements) {
				if (currentEObject instanceof RequiredInterfaceDefinition) {
					reqItfList.add((RequiredInterfaceDefinition) currentEObject);
				}
			}
		}
		return reqItfList;
	}

	private EList<ProvidedInterfaceDefinition> listAllProvidedInterfacesFromArchDefSuperTypes(TypeDefinition archDef){
		EList<TypeDefinition> superTypes = archDef.getSuperTypes();

		EList<ProvidedInterfaceDefinition> prvdItfList = new BasicEList<ProvidedInterfaceDefinition>();

		for (TypeDefinition currSuperArchDef : superTypes) {
			prvdItfList.addAll(getAllArchDefProvidedInterfaces(currSuperArchDef));
			// we need a recursion in all supertypes
			listAllProvidedInterfacesFromArchDefSuperTypes(currSuperArchDef);
		}

		return prvdItfList;
	}

	private EList<ProvidedInterfaceDefinition> listAllProvidedInterfacesFromArchDefSuperTypes(CompositeDefinition archDef){
		EList<CompositeSuperTypeDefinition> superTypes = archDef.getSuperTypes();

		EList<ProvidedInterfaceDefinition> prvdItfList = new BasicEList<ProvidedInterfaceDefinition>();

		for (CompositeSuperTypeDefinition currSuperArchDef : superTypes) {
			if (currSuperArchDef instanceof PrimitiveDefinition)
				prvdItfList.addAll(getAllArchDefProvidedInterfaces((CompositeDefinition) currSuperArchDef));
			else if (currSuperArchDef instanceof TypeDefinition)
				prvdItfList.addAll(getAllArchDefProvidedInterfaces((TypeDefinition) currSuperArchDef));
			
			// we need a recursion in all supertypes
			if (currSuperArchDef instanceof CompositeDefinition)
				listAllProvidedInterfacesFromArchDefSuperTypes((CompositeDefinition) currSuperArchDef);
			else if (currSuperArchDef instanceof TypeDefinition)
				listAllProvidedInterfacesFromArchDefSuperTypes((TypeDefinition) currSuperArchDef);
		}

		return prvdItfList;
	}
	
	private EList<ProvidedInterfaceDefinition> listAllProvidedInterfacesFromArchDefSuperTypes(PrimitiveDefinition archDef){
		EList<PrimitiveSuperTypeDefinition> superTypes = archDef.getSuperTypes();

		EList<ProvidedInterfaceDefinition> prvdItfList = new BasicEList<ProvidedInterfaceDefinition>();

		for (PrimitiveSuperTypeDefinition currSuperArchDef : superTypes) {
			if (currSuperArchDef instanceof PrimitiveDefinition)
				prvdItfList.addAll(getAllArchDefProvidedInterfaces((PrimitiveDefinition) currSuperArchDef));
			else if (currSuperArchDef instanceof TypeDefinition)
				prvdItfList.addAll(getAllArchDefProvidedInterfaces((TypeDefinition) currSuperArchDef));
			
			// we need a recursion in all supertypes
			if (currSuperArchDef instanceof PrimitiveDefinition)
				listAllProvidedInterfacesFromArchDefSuperTypes((PrimitiveDefinition) currSuperArchDef);
			else if (currSuperArchDef instanceof TypeDefinition)
				listAllProvidedInterfacesFromArchDefSuperTypes((TypeDefinition) currSuperArchDef);
		}

		return prvdItfList;
	}
	
	private EList<ProvidedInterfaceDefinition> getAllArchDefProvidedInterfaces(ArchitectureDefinition archDef) {
		EList<ProvidedInterfaceDefinition> reqItfList = new BasicEList<ProvidedInterfaceDefinition>();

		if (archDef instanceof TypeDefinition) {
			// Get all the elements
			EList<HostedInterfaceDefinition> elements = ((TypeDefinition) archDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			for (EObject currentEObject : elements) {
				if (currentEObject instanceof ProvidedInterfaceDefinition) {
					reqItfList.add((ProvidedInterfaceDefinition) currentEObject);
				}
			}
		} else if (archDef instanceof CompositeDefinition) {
			// Get all the elements
			EList<CompositeElement> elements = ((CompositeDefinition) archDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			for (EObject currentEObject : elements) {
				if (currentEObject instanceof ProvidedInterfaceDefinition) {
					reqItfList.add((ProvidedInterfaceDefinition) currentEObject);
				}
			}
		} else if (archDef instanceof PrimitiveDefinition) {
			// Get all the elements
			EList<PrimitiveElement> elements = ((PrimitiveDefinition) archDef).getElements();
			// Then filter for RequiredInterfaceDefinition(s)

			for (EObject currentEObject : elements) {
				if (currentEObject instanceof ProvidedInterfaceDefinition) {
					reqItfList.add((ProvidedInterfaceDefinition) currentEObject);
				}
			}
		}
		return reqItfList;
	}

	//	public IScope getScope(SubComponentDefinition subCompDef, EReference ref){
	//		return null;
	//		
	//	}


}
